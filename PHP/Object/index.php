<?php
// TODO: final 被修饰的类不能被继承
// TODO: clone 克隆对象
// TODO: __construct 构造方法
// TODO: __destruct  析构方法
// TODO: abstract 抽象类的定义   abstract class 类名称 {}
// TODO: interface 接口     interface 接口名称 {}     继承用: class A implements B {}
// TODO: __call() 当程序视图调用不存在
// TODO: __toString() 当使用 echo 或 printf 输出对象时,将对象转化为字符串
// TODO: __autoload() 自动实例化需要使用的类

class People {
    public function __toString()
    {
        // TODO: Implement __toString() method.
        return "我是toString的方法体";
    }
}
$peo = new People();
echo $peo;
echo "<p>";

// 抽象类和接口
/**
    抽象类: 抽象类是一种不能被实例化的类,只能作为其他类的父类使用。
           抽象类使用abstract关键字来声明。
 */
//abstract class Cate {
//    abstract function decocts($a, $b);
//    abstract function stir_frys($a, $b);
//    abstract function cooks($a, $b);
//    abstract function frys($a, $b);
//}
//class JL_Cate extends Cate {
//    public function decocts($a, $b) {
//        // TODO: Implement decocts() method.
//        echo "您点的菜是: ".$a."<br>";
//        echo "价格是: ".$b."<br>";
//    }
//    public function stir_frys($a, $b) {
//        // TODO: Implement stir_frys() method.
//        echo "您点的菜是: ".$a."<br>";
//        echo "价格是: ".$b."<br>";
//    }
//    public function cooks($a, $b) {
//        // TODO: Implement cooks() method.
//        echo "您点的菜是: ".$a."<br>";
//        echo "价格是: ".$b."<br>";
//    }
//    public function frys($a, $b) {
//        // TODO: Implement frys() method.
//        echo "您点的菜是: ".$a."<br>";
//        echo "价格是: ".$b."<br>";
//    }
//}
//$jl = new JL_Cate();
//$jl->decocts("小鸡炖蘑菇", "39元");
/**
    接口: 接口特性简化了对象、类的创建、增加了代码的可重性。但PHP只支持单继承。
 *        如果想实现多重继承,就要使用接口。PHP可以实现多个接口。
 */
//interface One {                             // 声明接口
//    const CONSTANT = 'CONSTANT value';      // 声明常量成员属性
//    function FunOne();                      // 声明抽象方法
//}
//echo One::CONSTANT."<br>";
//// 接口之间的继承
//interface Two extends One {    // 声明接口, 并指明继承对象
//    function FunTwo();         // 声明抽象方法
//}
// TODO: 接口的应用
//interface Person {
//    public function say();
//}
//interface Popedom {
//    public function money();
//}
//class Member implements Person,Popedom {
//    public function say() {
//        // TODO: Implement say() method.
//        echo "我只是一名普通员工, ";
//    }
//    public function money() {
//        // TODO: Implement money() method.
//        echo "我一个月的薪水是10元";
//    }
//}
//$man = new Member();
//$man->say();
//$man->money();
// TODO: 通过继承实现多态
abstract class Type {
    abstract function go_type();
}
class Type_Car extends Type {
    public function go_type() {
        // TODO: Implement go_type() method.
        echo "开着轿车去拉萨!";
    }
}
class Type_Bus extends Type {
    public function go_type() {
        // TODO: Implement go_type() method.
        echo "开着巴士去拉萨!";
    }
}
function change($obj) {
    if ($obj instanceof Type) {
        $obj->go_type();
    } else {
        echo "传入的参数不是一个对象!";
    }
}
echo "实例化Type_Car: ";
change(new Type_Car());
echo "<br>";
echo "实例化Type_Buss: ";
change(new Type_Bus());
echo "<p>";

// TODO: 通过接口实现多继承
interface Type_I {
    public function go_type();
}
class Type_Car_I implements Type_I {
    public function go_type() {
        // TODO: Implement go_type() method.
        echo "开着轿车去拉萨!";
    }
}
class Type_Bus_I implements Type_I {
    public function go_type() {
        // TODO: Implement go_type() method.
        echo "开着巴士去拉萨!";
    }
}
function change_i($obj) {
    if ($obj instanceof Type_I) {
        $obj->go_type();
    } else {
        echo "传入的参数不是一个对象!";
    }
}
echo "实例化 Type_Car_I: ";
change_i(new Type_Car_I());
echo "<br>";
echo "实例化Type_Bus_I: ";
change_i(new Type_Bus_I());
echo "<p>";



//// static关键字
//class Web {
//    static $NUM = "1";
//    static function change() {
//        echo "您是本站第".self::$NUM."位访客"."<br>";
//        self::$NUM++;
//    }
//}
//$web = new Web();
//echo "第一次通过对象调用: <br>";
//$web->change();
//$web->change();
//$web->change();
//echo "第二次通过对象调用: <br>";
//Web::change();
//Web::change();
//Web::change();



//// 覆盖子类(重写父类方法)
//class Car {
//    protected $wheel;
//    protected $steer;
//    protected $speed;
//    public function say_type() {
//        $this->wheel = "45.9cm";
//        $this->steer = "15.7cm";
//        $this->speed = "120m/s";
//    }
//}

//class SmallCar extends Car {
//    public function say_type() {
////        parent::say_type(); // TODO: Change the autogenerated stub
//        $this->wheel = "50.9cm";
//        $this->steer = "20cm";
//        $this->speed = "160m/s";
//    }
//    public function say_show() {
//        $this->say_type();
//        echo "Q7轿车轮胎尺寸: ".$this->wheel."<br>";
//        echo "Q7轿车方向盘尺寸: ".$this->steer."<br>";
//        echo "Q7轿车最高时速: ".$this->speed."<br>";
//    }
//}
//$car = new SmallCar();
//$car->say_show();


// TODO: "::"操作符
//class Car {
//    const NAME = "别克系列";     // 定义常量
//    public function bigType() {
//        echo "父类: ".Car::NAME;   // 常量的调用
//    }
//}
//
//class SmallCar extends Car {
//    const NAME = "别克君威";
//    public function smallType() {
//        echo parent::bigType()."\t";
//        echo "子类: ".self::NAME;
//    }
//}
//$car = new SmallCar();
//$car -> smallType();



// 继承
//class Fruit {
//    var $apple = "apple";    // 定义变量
//    var $banana = "banana";
//    var $orange = "orange";
//}
//
//class FruitType extends Fruit {  // 继承
//    var $grape = "grape";    // 定义子类变量
//}
//
//$fruit = new FruitType();   // 创建对象
//echo $fruit->apple.",".$fruit->banana.",".$fruit->orange.",".$fruit->grape;   // 调用类方法



/**
   构造方法: 当类被实例化后构造方法自动执行,所以如果用户希望在实例化的同时调用某个方法,可以把此方法通过this关键字调用。
 */
//class MySql {
//    var $localhost;
//    var $user_name;
//    var $pwd;
//    var $db;
//    var $conn;
//
//    public function __construct($localhost, $user_name, $pwd, $db) { // 构造方法
//        $this->localhost=$localhost;
//        $this->user_name=$user_name;
//        $this->pwd=$pwd;
//        $this->db=$db;
//        $this->connet();
//
//    }
//
//    public function connet() {
//        $this->conn=mysqli_connect($this->localhost, $this->user_name, $this->pwd, $this->db) or die("CONNECT MYSQL FALSE".mysqli_error($this->conn));
//        mysqli_query($this->conn, "SET NAMES utf8");
//    }
//
//    public function get_id() {
//        echo "MySQL服务器的用户名: ".$this->user_name."<br>";
//        echo "MySQL服务器密码: ".$this->pwd."<br>";
//    }
//
//    function __destruct() {
//        // TODO: Implement __destruct() method.
//        // 方法体,完成一个对象销毁前得清理任务
//    }
//}
//$msl = new MySql("localhost", "root", "root", "db_database12");
//$msl->get_id();



//class cloneDB {
//    var $aa;
//    var $bb;
//    var $cc;
//    var $dd;
//    var $ee;
//    const PI = 3.1415;
//
//    function abc() {
//        echo "abcabcabc----";
//    }
//    function bcd() {
//
//    }
//    function cdf() {
//        $this->bb = 100;
//        return $this->bb;
//    }
//}
//
//
//$clone1 = new cloneDB();
//$clone2 = new cloneDB();
//$clone3 = new cloneDB();
//$clone1->aa = 10;
//echo $clone1->aa;
//echo "<br>";
//$clone2->abc();
//echo "<br>";
//echo $clone1->aa;
//echo "<br>";
//echo cloneDB::PI;
//echo "<br>";
//echo $clone3->cdf();
//
?>